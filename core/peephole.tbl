// ***** BEGIN LICENSE BLOCK *****
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
//
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
//
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
//
// The Original Code is [Open Source Virtual Machine.].
//
// The Initial Developer of the Original Code is
// Adobe System Incorporated.
// Portions created by the Initial Developer are Copyright (C) 2004-2006
// the Initial Developer. All Rights Reserved.
//
// Contributor(s):
//   Adobe AS3 Team
//
// Alternatively, the contents of this file may be used under the terms of
// either the GNU General Public License Version 2 or later (the "GPL"), or
// the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
// in which case the provisions of the GPL or the LGPL are applicable instead
// of those above. If you wish to allow use of your version of this file only
// under the terms of either the GPL or the LGPL, and not to allow others to
// use your version of this file under the terms of the MPL, indicate your
// decision by deleting the provisions above and replace them with the notice
// and other provisions required by the GPL or the LGPL. If you do not delete
// the provisions above, a recipient may use your version of this file under
// the terms of any one of the MPL, the GPL or the LGPL.
//
// ***** END LICENSE BLOCK ***** */

// Peephole and superword optimization patterns for the word-code interpreter.
// See comments in utils/peephole.as for more information.
//
// We assume the compiler does a decent job of generating eg IFLT, and
// not LESSTHAN IFTRUE, so there's no despecialization in the verifier
// to break IFLT apart, and no specialization in the peephole optimizer
// to merge that sequence (either in a larger context or by itself).
// This is only a simplifying measure.
//
// On the other hand, we depend on eg GETLOCAL2 being despecialized as GETLOCAL 2,
// and we respecialize here if the instruction is not consumed as part of a larger
// pattern.


// Get multiple locals

pattern  OP_getlocal ; OP_getlocal
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_get2locals ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_getlocal
guard    $0.1 < 1024 && $1.1 < 1024 && $2.1 < 1024
action   OP_ext_get3locals ; ($2.1 << 20) | ($1.1 << 10) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_getlocal ; OP_getlocal
guard    $0.1 < 256 && $1.1 < 256 && $2.1 < 256 && $3.1 < 256
action   OP_ext_get4locals ; ($3.1 << 24) | ($2.1 << 16) | ($1.1 << 8) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_getlocal ; OP_getlocal ; OP_getlocal
guard    $0.1 < 64 && $1.1 < 64 && $2.1 < 64 && $3.1 < 64 && $4.1 < 64
action   OP_ext_get5locals ; ($4.1 << 24) | ($3.1 << 18) | ($2.1 << 12) | ($1.1 << 6) | $0.1


// Get two locals and perform arithmetic, possibly with a store (in the case of add only)

pattern  OP_getlocal ; OP_getlocal ; OP_add
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_add_ll ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_add; OP_setlocal
guard    $0.1 < 1024 && $1.1 < 1024 && $3.1 < 1024
action   OP_ext_add_set_lll ; ($3.1 << 20) | ($1.1 << 10) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_subtract
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_subtract_ll ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_multiply
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_multiply_ll ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_divide
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_divide_ll ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_modulo
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_modulo_ll ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_bitand
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_bitand_ll ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_bitor
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_bitor_ll ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_bitxor
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_bitxor_ll ; ($1.1 << 16) | $0.1


// Get one local, one immediate, and perform arithmetic

pattern  OP_getlocal ; OP_ext_pushbits ; OP_add
action   OP_ext_add_lb ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_subtract
action   OP_ext_subtract_lb ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_multiply
action   OP_ext_multiply_lb ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_divide
action   OP_ext_divide_lb ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_bitand
action   OP_ext_bitand_lb ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_bitor
action   OP_ext_bitor_lb ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_bitxor
action   OP_ext_bitxor_lb ; $0.1 ; $1.1


// Compare two locals and branch on condition

pattern  OP_getlocal ; OP_getlocal ; OP_iflt
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_iflt_ll ; $2.1 ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_ifnlt
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_ifnlt_ll ; $2.1 ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_ifle
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_ifle_ll ; $2.1 ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_ifnle
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_ifnle_ll ; $2.1 ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_ifgt
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_ifgt_ll ; $2.1 ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_ifngt
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_ifngt_ll ; $2.1 ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_ifge
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_ifge_ll ; $2.1 ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_ifnge
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_ifnge_ll ; $2.1 ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_ifeq
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_ifeq_ll ; $2.1 ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_ifne
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_ifne_ll ; $2.1 ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_ifstricteq
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_ifstricteq_ll ; $2.1 ; ($1.1 << 16) | $0.1

pattern  OP_getlocal ; OP_getlocal ; OP_ifstrictne
guard    $0.1 < 65536 && $1.1 < 65536
action   OP_ext_ifstrictne_ll ; $2.1 ; ($1.1 << 16) | $0.1


// Compare local with constant and branch on condition

pattern  OP_getlocal ; OP_ext_pushbits ; OP_iflt
action   OP_ext_iflt_lb ; $2.1 ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_ifnlt
action   OP_ext_ifnlt_lb ; $2.1 ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_ifle
action   OP_ext_ifle_lb ; $2.1 ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_ifnle
action   OP_ext_ifnle_lb ; $2.1 ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_ifgt
action   OP_ext_ifgt_lb ; $2.1 ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_ifngt
action   OP_ext_ifngt_lb ; $2.1 ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_ifge
action   OP_ext_ifge_lb ; $2.1 ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_ifnge
action   OP_ext_ifnge_lb ; $2.1 ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_ifeq
action   OP_ext_ifeq_lb ; $2.1 ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_ifne
action   OP_ext_ifne_lb ; $2.1 ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_ifstricteq
action   OP_ext_ifstricteq_lb ; $2.1 ; $0.1 ; $1.1

pattern  OP_getlocal ; OP_ext_pushbits ; OP_ifstrictne
action   OP_ext_ifstrictne_lb ; $2.1 ; $0.1 ; $1.1


// Miscellaneous

pattern  OP_setlocal ; OP_getlocal
guard    $0.1 == $1.1
action   OP_ext_storelocal ; $0.1

pattern  OP_swap ; OP_pop
action   OP_ext_swap_pop


// Specialize instructions that were despecialized by the verifier.

pattern  OP_getlocal
guard    $0.1 < 4
action   OP_getlocal0 + $0.1

pattern  OP_setlocal
guard    $0.1 < 4
action   OP_setlocal0 + $0.1


// This is an example of a sequence that would not appear in a rational instruction
// set but which might occur frequently in an executed sequence even after the 
// more common patterns above have been accounted for.  Only iterative analysis will tell.
//
// Another consideration here is that it may make sense to conflate storelocal and shiftlocal,
// since it's dispatches we want to reduce as much as possible.
//
//pattern  OP_setlocal ; OP_getlocal
//guard    $0.1 < 65536 && $1.1 < 65536
//action   OP_ext_shiftlocal ; ($1.1 << 16) | $0.1

