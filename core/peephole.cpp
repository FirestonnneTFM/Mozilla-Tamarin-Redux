// Generated by utils/peephole.as

#include "avmplus.h"

namespace avmplus
{
#ifdef AVMPLUS_PEEPHOLE_OPTIMIZER

Translator::peep_state_t Translator::states[] = {
//n  s  t  g  f
{ 0, 0, 0, 0, 0 }, // Invalid
{ 0, 0, 0, 5, 0 }, //    OP_getlocal OP_getlocal OP_getlocal OP_getlocal OP_getlocal
{ 1, 0, 0, 4, 0 }, //    OP_getlocal OP_getlocal OP_getlocal OP_getlocal
{ 1, 0, 1, 3, 0 }, //    OP_getlocal OP_getlocal OP_getlocal
{ 0, 3, 0, 7, 48 }, //    OP_getlocal OP_getlocal OP_add OP_setlocal
{ 1, 0, 2, 6, 0 }, //    OP_getlocal OP_getlocal OP_add
{ 0, 0, 0, 8, 0 }, //    OP_getlocal OP_getlocal OP_subtract
{ 0, 0, 0, 9, 0 }, //    OP_getlocal OP_getlocal OP_multiply
{ 0, 0, 0, 10, 0 }, //    OP_getlocal OP_getlocal OP_divide
{ 0, 0, 0, 11, 0 }, //    OP_getlocal OP_getlocal OP_modulo
{ 0, 0, 0, 12, 0 }, // 10  OP_getlocal OP_getlocal OP_bitand
{ 0, 0, 0, 13, 0 }, //    OP_getlocal OP_getlocal OP_bitor
{ 0, 0, 0, 14, 0 }, //    OP_getlocal OP_getlocal OP_bitxor
{ 0, 0, 0, 15, 0 }, //    OP_getlocal OP_getlocal OP_iflt
{ 0, 0, 0, 16, 0 }, //    OP_getlocal OP_getlocal OP_ifnlt
{ 0, 0, 0, 17, 0 }, //    OP_getlocal OP_getlocal OP_ifle
{ 0, 0, 0, 18, 0 }, //    OP_getlocal OP_getlocal OP_ifnle
{ 0, 0, 0, 19, 0 }, //    OP_getlocal OP_getlocal OP_ifgt
{ 0, 0, 0, 20, 0 }, //    OP_getlocal OP_getlocal OP_ifngt
{ 0, 0, 0, 21, 0 }, //    OP_getlocal OP_getlocal OP_ifge
{ 0, 0, 0, 22, 0 }, // 20  OP_getlocal OP_getlocal OP_ifnge
{ 0, 0, 0, 23, 0 }, //    OP_getlocal OP_getlocal OP_ifeq
{ 0, 0, 0, 24, 0 }, //    OP_getlocal OP_getlocal OP_ifne
{ 0, 0, 0, 25, 0 }, //    OP_getlocal OP_getlocal OP_ifstricteq
{ 0, 0, 0, 26, 0 }, //    OP_getlocal OP_getlocal OP_ifstrictne
{ 21, 0, 3, 2, 0 }, //    OP_getlocal OP_getlocal
{ 0, 0, 0, 27, 0 }, //    OP_getlocal OP_ext_pushbits OP_add
{ 0, 0, 0, 28, 0 }, //    OP_getlocal OP_ext_pushbits OP_subtract
{ 0, 0, 0, 29, 0 }, //    OP_getlocal OP_ext_pushbits OP_multiply
{ 0, 0, 0, 30, 0 }, //    OP_getlocal OP_ext_pushbits OP_divide
{ 0, 0, 0, 31, 0 }, // 30  OP_getlocal OP_ext_pushbits OP_bitand
{ 0, 0, 0, 32, 0 }, //    OP_getlocal OP_ext_pushbits OP_bitor
{ 0, 0, 0, 33, 0 }, //    OP_getlocal OP_ext_pushbits OP_bitxor
{ 0, 0, 0, 34, 0 }, //    OP_getlocal OP_ext_pushbits OP_iflt
{ 0, 0, 0, 35, 0 }, //    OP_getlocal OP_ext_pushbits OP_ifnlt
{ 0, 0, 0, 36, 0 }, //    OP_getlocal OP_ext_pushbits OP_ifle
{ 0, 0, 0, 37, 0 }, //    OP_getlocal OP_ext_pushbits OP_ifnle
{ 0, 0, 0, 38, 0 }, //    OP_getlocal OP_ext_pushbits OP_ifgt
{ 0, 0, 0, 39, 0 }, //    OP_getlocal OP_ext_pushbits OP_ifngt
{ 0, 0, 0, 40, 0 }, //    OP_getlocal OP_ext_pushbits OP_ifge
{ 0, 0, 0, 41, 0 }, // 40  OP_getlocal OP_ext_pushbits OP_ifnge
{ 0, 0, 0, 42, 0 }, //    OP_getlocal OP_ext_pushbits OP_ifeq
{ 0, 0, 0, 43, 0 }, //    OP_getlocal OP_ext_pushbits OP_ifne
{ 0, 0, 0, 44, 0 }, //    OP_getlocal OP_ext_pushbits OP_ifstricteq
{ 0, 0, 0, 45, 0 }, //    OP_getlocal OP_ext_pushbits OP_ifstrictne
{ 19, 0, 24, 0, 0 }, //    OP_getlocal OP_ext_pushbits
{ 2, 0, 43, 1, 0 }, //    OP_getlocal
{ 0, 1, 0, 47, 46 }, //    OP_setlocal OP_getlocal
{ 1, 0, 45, 46, 0 }, //    OP_setlocal
{ 0, 0, 0, 48, 0 }, //    OP_swap OP_pop
{ 1, 0, 46, 0, 0 }, // 50  OP_swap
};

Translator::peep_transition_t Translator::transitions[] = {
{ OP_getlocal, 1 },
{ OP_getlocal, 2 },
{ OP_setlocal, 4 },
{ OP_ifnlt, 14 },
{ OP_ifnle, 16 },
{ OP_ifngt, 18 },
{ OP_ifnge, 20 },
{ OP_ifeq, 21 },
{ OP_ifne, 22 },
{ OP_iflt, 13 },
{ OP_ifle, 15 }, // 10
{ OP_ifgt, 17 },
{ OP_ifge, 19 },
{ OP_ifstricteq, 23 },
{ OP_ifstrictne, 24 },
{ OP_getlocal, 3 },
{ OP_add, 5 },
{ OP_subtract, 6 },
{ OP_multiply, 7 },
{ OP_divide, 8 },
{ OP_modulo, 9 }, // 20
{ OP_bitand, 10 },
{ OP_bitor, 11 },
{ OP_bitxor, 12 },
{ OP_ifnlt, 34 },
{ OP_ifnle, 36 },
{ OP_ifngt, 38 },
{ OP_ifnge, 40 },
{ OP_ifeq, 41 },
{ OP_ifne, 42 },
{ OP_iflt, 33 }, // 30
{ OP_ifle, 35 },
{ OP_ifgt, 37 },
{ OP_ifge, 39 },
{ OP_ifstricteq, 43 },
{ OP_ifstrictne, 44 },
{ OP_add, 26 },
{ OP_subtract, 27 },
{ OP_multiply, 28 },
{ OP_divide, 29 },
{ OP_bitand, 30 }, // 40
{ OP_bitor, 31 },
{ OP_bitxor, 32 },
{ OP_getlocal, 25 },
{ OP_ext_pushbits, 45 },
{ OP_getlocal, 47 },
{ OP_pop, 49 },
};

uint16 Translator::toplevel[] = {
0, 0, 0, 0, 0, 0, 0, 0, // -                      OP_bkpt                OP_nop                 OP_throw               OP_getsuper            OP_setsuper            OP_dxns                OP_dxnslate           
0, 0, 0, 0, 0, 0, 0, 0, // OP_kill                OP_label               -                      -                      OP_ifnlt               OP_ifnle               OP_ifngt               OP_ifnge              
0, 0, 0, 0, 0, 0, 0, 0, // OP_jump                OP_iftrue              OP_iffalse             OP_ifeq                OP_ifne                OP_iflt                OP_ifle                OP_ifgt               
0, 0, 0, 0, 0, 0, 0, 0, // OP_ifge                OP_ifstricteq          OP_ifstrictne          OP_lookupswitch        OP_pushwith            OP_popscope            OP_nextname            OP_hasnext            
0, 0, 0, 0, 0, 0, 0, 0, // OP_pushnull            OP_pushundefined       -                      OP_nextvalue           OP_pushbyte            OP_pushshort           OP_pushtrue            OP_pushfalse          
0, 0, 0, 50, 0, 0, 0, 0, // OP_pushnan             OP_pop                 OP_dup                 OP_swap                OP_pushstring          OP_pushint             OP_pushuint            OP_pushdouble         
0, 0, 0, 0, 0, 0, 0, 0, // OP_pushscope           OP_pushnamespace       OP_hasnext2            -                      -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // -                      -                      -                      -                      -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // OP_newfunction         OP_call                OP_construct           OP_callmethod          OP_callstatic          OP_callsuper           OP_callproperty        OP_returnvoid         
0, 0, 0, 0, 0, 0, 0, 0, // OP_returnvalue         OP_constructsuper      OP_constructprop       OP_callsuperid         OP_callproplex         OP_callinterface       OP_callsupervoid       OP_callpropvoid       
0, 0, 0, 0, 0, 0, 0, 0, // -                      -                      -                      OP_applytype           -                      OP_newobject           OP_newarray            OP_newactivation      
0, 0, 0, 0, 0, 0, 0, 0, // OP_newclass            OP_getdescendants      OP_newcatch            -                      -                      OP_findpropstrict      OP_findproperty        OP_finddef            
0, 0, 46, 48, 0, 0, 0, 0, // OP_getlex              OP_setproperty         OP_getlocal            OP_setlocal            OP_getglobalscope      OP_getscopeobject      OP_getproperty         OP_getouterscope      
0, 0, 0, 0, 0, 0, 0, 0, // OP_initproperty        -                      OP_deleteproperty      -                      OP_getslot             OP_setslot             OP_getglobalslot       OP_setglobalslot      
0, 0, 0, 0, 0, 0, 0, 0, // OP_convert_s           OP_esc_xelem           OP_esc_xattr           OP_convert_i           OP_convert_u           OP_convert_d           OP_convert_b           OP_convert_o          
0, 0, 0, 0, 0, 0, 0, 0, // OP_checkfilter         -                      -                      -                      -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // OP_coerce              OP_coerce_b            OP_coerce_a            OP_coerce_i            OP_coerce_d            OP_coerce_s            OP_astype              OP_astypelate         
0, 0, 0, 0, 0, 0, 0, 0, // OP_coerce_u            OP_coerce_o            -                      -                      -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // OP_negate              OP_increment           OP_inclocal            OP_decrement           OP_declocal            OP_typeof              OP_not                 OP_bitnot             
0, 0, 0, 0, 0, 0, 0, 0, // -                      -                      OP_concat              OP_add_d               -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // OP_add                 OP_subtract            OP_multiply            OP_divide              OP_modulo              OP_lshift              OP_rshift              OP_urshift            
0, 0, 0, 0, 0, 0, 0, 0, // OP_bitand              OP_bitor               OP_bitxor              OP_equals              OP_strictequals        OP_lessthan            OP_lessequals          OP_greaterthan        
0, 0, 0, 0, 0, 0, 0, 0, // OP_greaterequals       OP_instanceof          OP_istype              OP_istypelate          OP_in                  -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // -                      -                      -                      -                      -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // OP_increment_i         OP_decrement_i         OP_inclocal_i          OP_declocal_i          OP_negate_i            OP_add_i               OP_subtract_i          OP_multiply_i         
0, 0, 0, 0, 0, 0, 0, 0, // -                      -                      -                      -                      -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // OP_getlocal0           OP_getlocal1           OP_getlocal2           OP_getlocal3           OP_setlocal0           OP_setlocal1           OP_setlocal2           OP_setlocal3          
0, 0, 0, 0, 0, 0, 0, 0, // -                      -                      -                      -                      -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // -                      -                      -                      -                      -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // -                      -                      -                      -                      -                      -                      OP_abs_jump            OP_debug              
0, 0, 0, 0, 0, 0, 0, 0, // OP_debugline           OP_debugfile           OP_bkptline            OP_timestamp           -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // -                      -                      -                      -                      -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // -                      OP_ext_pushbits        OP_ext_push_doublebits OP_ext_get2locals      OP_ext_get3locals      OP_ext_get4locals      OP_ext_get5locals      OP_ext_storelocal     
0, 0, 0, 0, 0, 0, 0, 0, // OP_ext_add_ll          OP_ext_add_set_lll     OP_ext_subtract_ll     OP_ext_multiply_ll     OP_ext_divide_ll       OP_ext_modulo_ll       OP_ext_bitand_ll       OP_ext_bitor_ll       
0, 0, 0, 0, 0, 0, 0, 0, // OP_ext_bitxor_ll       OP_ext_add_lb          OP_ext_subtract_lb     OP_ext_multiply_lb     OP_ext_divide_lb       OP_ext_bitand_lb       OP_ext_bitor_lb        OP_ext_bitxor_lb      
0, 0, 0, 0, 0, 0, 0, 0, // OP_ext_iflt_ll         OP_ext_ifnlt_ll        OP_ext_ifle_ll         OP_ext_ifnle_ll        OP_ext_ifgt_ll         OP_ext_ifngt_ll        OP_ext_ifge_ll         OP_ext_ifnge_ll       
0, 0, 0, 0, 0, 0, 0, 0, // OP_ext_ifeq_ll         OP_ext_ifne_ll         OP_ext_ifstricteq_ll   OP_ext_ifstrictne_ll   OP_ext_iflt_lb         OP_ext_ifnlt_lb        OP_ext_ifle_lb         OP_ext_ifnle_lb       
0, 0, 0, 0, 0, 0, 0, 0, // OP_ext_ifgt_lb         OP_ext_ifngt_lb        OP_ext_ifge_lb         OP_ext_ifnge_lb        OP_ext_ifeq_lb         OP_ext_ifne_lb         OP_ext_ifstricteq_lb   OP_ext_ifstrictne_lb  
0, 0, 0, 0, 0, 0, 0, 0, // OP_ext_swap_pop        -                      -                      -                      -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // -                      -                      -                      -                      -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // -                      -                      -                      -                      -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // -                      -                      -                      -                      -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, 0, 0, // -                      -                      -                      -                      -                      -                      -                      -                     
0, 0, 0, 0, 0, 0, // -                      -                      -                      -                      -                      -                     
};

bool Translator::commit(uint32 action)
{
    switch (action) {
    case 1:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal));
        if (I[0][1] < 4) {
            S[0] = OP_getlocal0 + I[0][1];
            R[0] = NEW_OPCODE(OP_getlocal0 + I[0][1]);
            return replace(1,1);
        }
        return false;
    case 2:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            S[0] = OP_ext_get2locals;
            R[0] = NEW_OPCODE(OP_ext_get2locals);
            R[1] = (I[1][1] << 16) | I[0][1];
            return replace(2,2);
        }
        return false;
    case 3:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_getlocal));
        if (I[0][1] < 1024 && I[1][1] < 1024 && I[2][1] < 1024) {
            S[0] = OP_ext_get3locals;
            R[0] = NEW_OPCODE(OP_ext_get3locals);
            R[1] = (I[2][1] << 20) | (I[1][1] << 10) | I[0][1];
            return replace(3,2);
        }
        return false;
    case 4:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_getlocal) && I[3][0] == NEW_OPCODE(OP_getlocal));
        if (I[0][1] < 256 && I[1][1] < 256 && I[2][1] < 256 && I[3][1] < 256) {
            S[0] = OP_ext_get4locals;
            R[0] = NEW_OPCODE(OP_ext_get4locals);
            R[1] = (I[3][1] << 24) | (I[2][1] << 16) | (I[1][1] << 8) | I[0][1];
            return replace(4,2);
        }
        return false;
    case 5:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_getlocal) && I[3][0] == NEW_OPCODE(OP_getlocal) && I[4][0] == NEW_OPCODE(OP_getlocal));
        if (I[0][1] < 64 && I[1][1] < 64 && I[2][1] < 64 && I[3][1] < 64 && I[4][1] < 64) {
            S[0] = OP_ext_get5locals;
            R[0] = NEW_OPCODE(OP_ext_get5locals);
            R[1] = (I[4][1] << 24) | (I[3][1] << 18) | (I[2][1] << 12) | (I[1][1] << 6) | I[0][1];
            return replace(5,2);
        }
        return false;
    case 6:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_add));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            S[0] = OP_ext_add_ll;
            R[0] = NEW_OPCODE(OP_ext_add_ll);
            R[1] = (I[1][1] << 16) | I[0][1];
            return replace(3,2);
        }
        return false;
    case 7:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_add) && I[3][0] == NEW_OPCODE(OP_setlocal));
        if (I[0][1] < 1024 && I[1][1] < 1024 && I[3][1] < 1024) {
            S[0] = OP_ext_add_set_lll;
            R[0] = NEW_OPCODE(OP_ext_add_set_lll);
            R[1] = (I[3][1] << 20) | (I[1][1] << 10) | I[0][1];
            return replace(4,2);
        }
        return false;
    case 8:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_subtract));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            S[0] = OP_ext_subtract_ll;
            R[0] = NEW_OPCODE(OP_ext_subtract_ll);
            R[1] = (I[1][1] << 16) | I[0][1];
            return replace(3,2);
        }
        return false;
    case 9:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_multiply));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            S[0] = OP_ext_multiply_ll;
            R[0] = NEW_OPCODE(OP_ext_multiply_ll);
            R[1] = (I[1][1] << 16) | I[0][1];
            return replace(3,2);
        }
        return false;
    case 10:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_divide));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            S[0] = OP_ext_divide_ll;
            R[0] = NEW_OPCODE(OP_ext_divide_ll);
            R[1] = (I[1][1] << 16) | I[0][1];
            return replace(3,2);
        }
        return false;
    case 11:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_modulo));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            S[0] = OP_ext_modulo_ll;
            R[0] = NEW_OPCODE(OP_ext_modulo_ll);
            R[1] = (I[1][1] << 16) | I[0][1];
            return replace(3,2);
        }
        return false;
    case 12:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_bitand));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            S[0] = OP_ext_bitand_ll;
            R[0] = NEW_OPCODE(OP_ext_bitand_ll);
            R[1] = (I[1][1] << 16) | I[0][1];
            return replace(3,2);
        }
        return false;
    case 13:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_bitor));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            S[0] = OP_ext_bitor_ll;
            R[0] = NEW_OPCODE(OP_ext_bitor_ll);
            R[1] = (I[1][1] << 16) | I[0][1];
            return replace(3,2);
        }
        return false;
    case 14:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_bitxor));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            S[0] = OP_ext_bitxor_ll;
            R[0] = NEW_OPCODE(OP_ext_bitxor_ll);
            R[1] = (I[1][1] << 16) | I[0][1];
            return replace(3,2);
        }
        return false;
    case 15:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_iflt));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_iflt_ll;
            R[0] = NEW_OPCODE(OP_ext_iflt_ll);
            R[1] = I[2][1];
            R[2] = (I[1][1] << 16) | I[0][1];
            return replace(3,3,true);
        }
        return false;
    case 16:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_ifnlt));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifnlt_ll;
            R[0] = NEW_OPCODE(OP_ext_ifnlt_ll);
            R[1] = I[2][1];
            R[2] = (I[1][1] << 16) | I[0][1];
            return replace(3,3,true);
        }
        return false;
    case 17:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_ifle));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifle_ll;
            R[0] = NEW_OPCODE(OP_ext_ifle_ll);
            R[1] = I[2][1];
            R[2] = (I[1][1] << 16) | I[0][1];
            return replace(3,3,true);
        }
        return false;
    case 18:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_ifnle));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifnle_ll;
            R[0] = NEW_OPCODE(OP_ext_ifnle_ll);
            R[1] = I[2][1];
            R[2] = (I[1][1] << 16) | I[0][1];
            return replace(3,3,true);
        }
        return false;
    case 19:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_ifgt));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifgt_ll;
            R[0] = NEW_OPCODE(OP_ext_ifgt_ll);
            R[1] = I[2][1];
            R[2] = (I[1][1] << 16) | I[0][1];
            return replace(3,3,true);
        }
        return false;
    case 20:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_ifngt));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifngt_ll;
            R[0] = NEW_OPCODE(OP_ext_ifngt_ll);
            R[1] = I[2][1];
            R[2] = (I[1][1] << 16) | I[0][1];
            return replace(3,3,true);
        }
        return false;
    case 21:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_ifge));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifge_ll;
            R[0] = NEW_OPCODE(OP_ext_ifge_ll);
            R[1] = I[2][1];
            R[2] = (I[1][1] << 16) | I[0][1];
            return replace(3,3,true);
        }
        return false;
    case 22:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_ifnge));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifnge_ll;
            R[0] = NEW_OPCODE(OP_ext_ifnge_ll);
            R[1] = I[2][1];
            R[2] = (I[1][1] << 16) | I[0][1];
            return replace(3,3,true);
        }
        return false;
    case 23:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_ifeq));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifeq_ll;
            R[0] = NEW_OPCODE(OP_ext_ifeq_ll);
            R[1] = I[2][1];
            R[2] = (I[1][1] << 16) | I[0][1];
            return replace(3,3,true);
        }
        return false;
    case 24:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_ifne));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifne_ll;
            R[0] = NEW_OPCODE(OP_ext_ifne_ll);
            R[1] = I[2][1];
            R[2] = (I[1][1] << 16) | I[0][1];
            return replace(3,3,true);
        }
        return false;
    case 25:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_ifstricteq));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifstricteq_ll;
            R[0] = NEW_OPCODE(OP_ext_ifstricteq_ll);
            R[1] = I[2][1];
            R[2] = (I[1][1] << 16) | I[0][1];
            return replace(3,3,true);
        }
        return false;
    case 26:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_getlocal) && I[2][0] == NEW_OPCODE(OP_ifstrictne));
        if (I[0][1] < 65536 && I[1][1] < 65536) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifstrictne_ll;
            R[0] = NEW_OPCODE(OP_ext_ifstrictne_ll);
            R[1] = I[2][1];
            R[2] = (I[1][1] << 16) | I[0][1];
            return replace(3,3,true);
        }
        return false;
    case 27:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_add));
        if (true) {
            S[0] = OP_ext_add_lb;
            R[0] = NEW_OPCODE(OP_ext_add_lb);
            R[1] = I[0][1];
            R[2] = I[1][1];
            return replace(3,3);
        }
        return false;
    case 28:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_subtract));
        if (true) {
            S[0] = OP_ext_subtract_lb;
            R[0] = NEW_OPCODE(OP_ext_subtract_lb);
            R[1] = I[0][1];
            R[2] = I[1][1];
            return replace(3,3);
        }
        return false;
    case 29:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_multiply));
        if (true) {
            S[0] = OP_ext_multiply_lb;
            R[0] = NEW_OPCODE(OP_ext_multiply_lb);
            R[1] = I[0][1];
            R[2] = I[1][1];
            return replace(3,3);
        }
        return false;
    case 30:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_divide));
        if (true) {
            S[0] = OP_ext_divide_lb;
            R[0] = NEW_OPCODE(OP_ext_divide_lb);
            R[1] = I[0][1];
            R[2] = I[1][1];
            return replace(3,3);
        }
        return false;
    case 31:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_bitand));
        if (true) {
            S[0] = OP_ext_bitand_lb;
            R[0] = NEW_OPCODE(OP_ext_bitand_lb);
            R[1] = I[0][1];
            R[2] = I[1][1];
            return replace(3,3);
        }
        return false;
    case 32:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_bitor));
        if (true) {
            S[0] = OP_ext_bitor_lb;
            R[0] = NEW_OPCODE(OP_ext_bitor_lb);
            R[1] = I[0][1];
            R[2] = I[1][1];
            return replace(3,3);
        }
        return false;
    case 33:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_bitxor));
        if (true) {
            S[0] = OP_ext_bitxor_lb;
            R[0] = NEW_OPCODE(OP_ext_bitxor_lb);
            R[1] = I[0][1];
            R[2] = I[1][1];
            return replace(3,3);
        }
        return false;
    case 34:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_iflt));
        if (true) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_iflt_lb;
            R[0] = NEW_OPCODE(OP_ext_iflt_lb);
            R[1] = I[2][1];
            R[2] = I[0][1];
            R[3] = I[1][1];
            return replace(3,4,true);
        }
        return false;
    case 35:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_ifnlt));
        if (true) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifnlt_lb;
            R[0] = NEW_OPCODE(OP_ext_ifnlt_lb);
            R[1] = I[2][1];
            R[2] = I[0][1];
            R[3] = I[1][1];
            return replace(3,4,true);
        }
        return false;
    case 36:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_ifle));
        if (true) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifle_lb;
            R[0] = NEW_OPCODE(OP_ext_ifle_lb);
            R[1] = I[2][1];
            R[2] = I[0][1];
            R[3] = I[1][1];
            return replace(3,4,true);
        }
        return false;
    case 37:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_ifnle));
        if (true) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifnle_lb;
            R[0] = NEW_OPCODE(OP_ext_ifnle_lb);
            R[1] = I[2][1];
            R[2] = I[0][1];
            R[3] = I[1][1];
            return replace(3,4,true);
        }
        return false;
    case 38:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_ifgt));
        if (true) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifgt_lb;
            R[0] = NEW_OPCODE(OP_ext_ifgt_lb);
            R[1] = I[2][1];
            R[2] = I[0][1];
            R[3] = I[1][1];
            return replace(3,4,true);
        }
        return false;
    case 39:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_ifngt));
        if (true) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifngt_lb;
            R[0] = NEW_OPCODE(OP_ext_ifngt_lb);
            R[1] = I[2][1];
            R[2] = I[0][1];
            R[3] = I[1][1];
            return replace(3,4,true);
        }
        return false;
    case 40:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_ifge));
        if (true) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifge_lb;
            R[0] = NEW_OPCODE(OP_ext_ifge_lb);
            R[1] = I[2][1];
            R[2] = I[0][1];
            R[3] = I[1][1];
            return replace(3,4,true);
        }
        return false;
    case 41:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_ifnge));
        if (true) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifnge_lb;
            R[0] = NEW_OPCODE(OP_ext_ifnge_lb);
            R[1] = I[2][1];
            R[2] = I[0][1];
            R[3] = I[1][1];
            return replace(3,4,true);
        }
        return false;
    case 42:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_ifeq));
        if (true) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifeq_lb;
            R[0] = NEW_OPCODE(OP_ext_ifeq_lb);
            R[1] = I[2][1];
            R[2] = I[0][1];
            R[3] = I[1][1];
            return replace(3,4,true);
        }
        return false;
    case 43:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_ifne));
        if (true) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifne_lb;
            R[0] = NEW_OPCODE(OP_ext_ifne_lb);
            R[1] = I[2][1];
            R[2] = I[0][1];
            R[3] = I[1][1];
            return replace(3,4,true);
        }
        return false;
    case 44:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_ifstricteq));
        if (true) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifstricteq_lb;
            R[0] = NEW_OPCODE(OP_ext_ifstricteq_lb);
            R[1] = I[2][1];
            R[2] = I[0][1];
            R[3] = I[1][1];
            return replace(3,4,true);
        }
        return false;
    case 45:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_getlocal) && I[1][0] == NEW_OPCODE(OP_ext_pushbits) && I[2][0] == NEW_OPCODE(OP_ifstrictne));
        if (true) {
            undoRelativeOffsetInJump();
            S[0] = OP_ext_ifstrictne_lb;
            R[0] = NEW_OPCODE(OP_ext_ifstrictne_lb);
            R[1] = I[2][1];
            R[2] = I[0][1];
            R[3] = I[1][1];
            return replace(3,4,true);
        }
        return false;
    case 46:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_setlocal));
        if (I[0][1] < 4) {
            S[0] = OP_setlocal0 + I[0][1];
            R[0] = NEW_OPCODE(OP_setlocal0 + I[0][1]);
            return replace(1,1);
        }
        return false;
    case 47:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_setlocal) && I[1][0] == NEW_OPCODE(OP_getlocal));
        if (I[0][1] == I[1][1]) {
            S[0] = OP_ext_storelocal;
            R[0] = NEW_OPCODE(OP_ext_storelocal);
            R[1] = I[0][1];
            return replace(2,2);
        }
        return false;
    case 48:
        AvmAssert(I[0][0] == NEW_OPCODE(OP_swap) && I[1][0] == NEW_OPCODE(OP_pop));
        if (true) {
            S[0] = OP_ext_swap_pop;
            R[0] = NEW_OPCODE(OP_ext_swap_pop);
            return replace(2,1);
        }
        return false;
    default:
        AvmAssert(!"Should not happen");
        return false;
    }
}

#endif // AVMPLUS_PEEPHOLE_OPTIMIZER
}
