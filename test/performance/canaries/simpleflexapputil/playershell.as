/* -*- Mode: C++; c-basic-offset: 4; indent-tabs-mode: t; tab-width: 4 -*- */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is [Open Source Virtual Machine.].
 *
 * The Initial Developer of the Original Code is
 * Adobe System Incorporated.
 * Portions created by the Initial Developer are Copyright (C) 2008
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Adobe AS3 Team
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
import flash.events.EventDispatcher
import flash.events.Event
import flash.events.MouseEvent
import flash.display.MovieClip
import flash.display.Sprite
import flash.display.DisplayObjectContainer
import flash.display.Stage
import flash.text.TextField

import flash.utils.*
import avmshell.*
import avmplus.*
import zlib.*

var log="// generated by playershell.as\n"+
     "import avmplus.*\n"+
     "import flash.events.*\n"+
     "import flash.display.Stage\n"+
     "import flash.utils.Timer\n"+
     "include \"playershell.as\"\n\n"+
     "var objects=new Array();\n"+
     "";

var objects:Array=new Array();
var constructors:Array=new Array();
var objectsnames:Array=new Array();
var abcfiles:Array=new Array();
var abcblocks:Array=new Array();
var abcblocknames:Array=new Array();
var nabcblocks:int=0;
var objectctr=0;

function usage() {
  print("playershell usage...\n"+
        
        "parseswf [swf]      - parses a swf, writes the abc files to disk\n"+
        "loadabcfile [abc]   - loads an abc file\n"+
        "loadabcblock[name]  - loads an abc block, use show blocks to see available blocks from a parseswf\n"+
        "showobjects         - shows the objects\n"+
        "showevents          - shows the registered events\n"+
        "showtimers          - shows active timers\n"+
        "showframes          - shows frame listeners\n"+
        "showblocks          - shows abc blocks available for loading\n"+
				"writeblocks				 - write blocks to disk\n"+
        "showdisplaylist     - shows the display list of the stage\n"+
        "showlog             - shows log of user commands\n"+
        "constructobject [n] - runs a constructor\n"+
        "event [name] [n]    - dispatches an event to the specified object\n"+
        "mouseevent [name] [n] - dispatches an event to the specified object\n"+
        "timer [n]           - tick a timer\n"+
        "set [command] [object#] [value] - sets a value,commands are totalFrames,currentFrame\n"+
        "savelog [file]      - saves log to a file\n"+
        "print [obj#] [value]- prints object property\n"+
        "runflex [swf]       - simulates player running a flex swf\n"+
        "exit                - quit\n"+
        "");
}
function go() {
  var exit=false;
  while (!exit) {
    System.write("$ ");
    line=System.readLine();
    var cmd=line;
    var rest="";
    if (cmd.indexOf(" ")>-1) {
      rest=cmd.substring(cmd.indexOf(" ")+1);
      cmd=cmd.substring(0,cmd.indexOf(" "));
    }
    switch(cmd) {
      case "parseswf":
       parseswf(rest);
       break;
      case "exit":
       exit=true;
       break;
      case "showlog":
       print("log:\n"+log);
       break;
      case "showtimers":
       showtimers();
       break;
      case "showblocks":
       showblocks();
       break;
      case "writeblocks":
       writeblocks();
       break;
      case "timer":
       timer(rest);
       break;
      case "event":
       dispatchevent(rest);
       break;
      case "mouseevent":
       dispatchmouseevent(rest);
       break;
      case "showobjects":
       showobjects();
       break;
      case "showevents":
       showevents();
       break;
      case "showdisplaylist":
       showdisplaylist();
       break;
      case "loadabcfile":
       loadabcfile(rest);
       break;
      case "loadabcblock":
       loadabcblock(rest);
       break;
      case "constructobject":
       constructobject(rest);
       break;
      case "runflex":
       runflex(rest);
       break;
      case "showframes":
       showframes();
       break;
      case "savelog":
       savelog(rest);
       break;
      case "set":
       set(rest);
       break;
      case "print":
       printit(rest);
       break;
      default:
       print("unknown command: "+cmd+"\n");
       usage();
       break;
    }
  }
}
function runflex(rest) {
 
 if (File.exists(rest)==false) {
     print("ERROR: file "+rest+" does not exist");
     return;
 }
 var start=System.getTimer();
 var start0=start;
 print("** loadabcfile avmglue.abc");
 loadabcfile("avmglue.abc");
 var last=System.getTimer();
 print("** finished loadabcfile avmglue.abc "+(last-start));
 start=last;

 print("** parseswf "+rest);
 parseswf(rest);
 var last=System.getTimer();
 print("** finished parseswf "+rest+" "+(last-start));
 start=last;

 print("** loadabcblock frame1");
 loadabcblock("frame1");
 var last=System.getTimer();
 print("** finished loadabcblock frame1 "+(last-start));
 start=last;

 print("** constructobject 0 // create SystemManager object");
 constructobject("0");
 var last=System.getTimer();
 print("** finished constructobject 0 "+(last-start));
 start=last;

 print("** event init 0 // dispatch init event to SystemManager");
 dispatchevent("init 0");
 var last=System.getTimer();
 print("** finished event init 0 "+(last-start));
 start=last;

 print("** loadabcblock frame2");
 loadabcblock("frame2");
 var last=System.getTimer();
 print("** finished loadabcblock frame2 "+(last-start));
 start=last;

 print("** set currentFrame 0 1 // set SystemManager frame to 1");
 set("currentFrame 0 1");
 var last=System.getTimer();
 print("** finished set currentFrame 0 1 "+(last-start));
 start=last;

 print("** event render  // dispatch render event to Stage, setup");
 Stage.getInstance().dispatchEvent(new Event("render"));
 var last=System.getTimer();
 print("** finished event render "+(last-start));
 start=last;

 print("** event render // dispatch render event to Stage, validateProperties");
 Stage.getInstance().dispatchEvent(new Event("render"));
 var last=System.getTimer();
 print("** finished event render "+(last-start));
 start=last;

 print("** event render // dispatch render event to Stage, validateSize");
 Stage.getInstance().dispatchEvent(new Event("render"));
 var last=System.getTimer();
 print("** finished event render "+(last-start));
 start=last;

 print("** event render // dispatch render event to Stage, validateDisplayList");
 Stage.getInstance().dispatchEvent(new Event("render"));
 var last=System.getTimer();
 print("** finished event render "+(last-start));
 start=last;

 print("** showdisplaylist");
 showdisplaylist();

 print("** finished at "+(System.getTimer()-start0));
}
var _printed;
function showdisplaylist() {
 print("showing stage displaylist");
 var stage=Stage.getInstance();
 _printed=new Array();
 printChildren(stage,0);
}
function printChildren(comp,n) {
  for (var i=0;i<_printed.length;i++) {
    if (_printed[i]==comp) return;
  }
  _printed.push(comp);
  var traceSave=tracer;
  tracer=traceOff;
  var s="";
  for (var i=0;i<n;i++) s+="   ";
  s+=""+comp+" ";
  if (comp is TextField && comp.text!="") {
    s+="text="+comp.text+" ";
  }
  s+="x="+comp.x+" y="+comp.y+" width="+comp.width+" height="+comp.height+" ";
  print(s);
  try {
    for (var i=0;i<comp._children.length;i++) {
      if (comp._children[i]!=Stage.getInstance())
      printChildren(comp._children[i],n+1);
    }
  } catch (e) {
  }
  tracer=traceSave;
}
function printit(rest) {
 if (rest=="") {
   print("ERROR: print [obj#] [value]");
 } else {
  var t=tracer;
  tracer=traceOff;
  try {
   var n,value;
   if (rest.indexOf(" ")==-1) {
     n=int(rest);
     value="";
   } else {
     n=int(rest.substring(0,rest.indexOf(" ")));
     value=rest.substring(rest.indexOf(" ")+1);
   }
   if (n<0 || Sprite.objectlist.length<=n) {
     print("ERROR: object "+n+" is not valid, enter number between 0 and "+Sprite.objectlist.length);
     return;
   }
   if (value=="") {
     print("printing all properties for "+Sprite.objectlist[n]);
     for (var p in Sprite.objectlist[n]) {
       print(Sprite.objectlist[n]+"."+p+" = "+Sprite.objectlist[n][p]);
     }
   } else {
     print(Sprite.objectlist[n]+"."+value+" = "+Sprite.objectlist[n][value]);
     tracer=t;
   }
  } catch (e) {
   print(e.getStackTrace());
  }
  tracer=t;
 }  
}
function savelog(rest) {
  var s=log+
     "// the go() line puts in interactive shell comment out to automated\n"+
     "go();\n";
  if (rest=="") {
    print("ERROR: savelog <filename>");
  } else {
    try {
      File.write(rest,s);  
    } catch (e) {
      print("ERROR: exception "+e);
      print(e.getStackTrace());
    }
    print("wrote "+rest);
    print("to compile: java -jar $ASC -import $GLOBALABC -import $SHELLABC "+rest);
  }
}
function showtimers() {
  var timerlist=Timer._timers;
  print("timers "+timerlist.length);
  for (var i=0;i<timerlist.length;i++) {
    print("timer ["+i+"] "+timerlist[i]);
  }
}
function showblocks() {
  print("show abc blocks");
  for (var i=0;i<nabcblocks;i++) {
    print("name="+abcblocknames[i]+" length="+abcblocks[i].length);
  }
}
function writeblocks() {
  print("write abc blocks");
  for (var i=0;i<nabcblocks;i++) {
    var name=abcblocknames[i];
    if (name=="") name="block1";
    name+=".abc";
    print("writing name="+name);
    abcblocks[i].writeFile(name);
//    CONFIG::tracing { File.writeByteArray(name,abcblocks[i]); }
  }
}
function timer(num) {
  var n=int(num);
  var timerlist=Timer._timers;
  print("calling timer tick on "+timerlist[n]);
  if (timerlist[n]==undefined) {
    print("ERROR: timer "+n+" is undefined");
  } else {
    timerlist[n].tick();
    log+="//tick timer "+n+"\n"+
         "print(\"*** tick timer "+n+" ***\");\n"+
         "Timer._timers["+n+"].tick();\n";
     
    print("finished timer tick on "+timerlist[n]);
  }
}
function showevents() {
  var elist=EventDispatcher._objectlist;
  var emap=EventDispatcher._objectmap;
  print("events with listeners "+elist.length);
  for (var i=0;i<elist.length;i++) {
    print("["+i+"]="+elist[i]);
    for (var j=0;j<emap[i]._listenersNames.length;j++) {
      print("  "+emap[i]._listenersNames[j]+
            " (#func): "+emap[i]._listeners[emap[i]._listenersNames[j]].length+
            " (#call): "+emap[i]._listenersCalls[emap[i]._listenersNames[j]]+
            "");
    }
  }
}
function dispatchevent(rest) {
  var elist=EventDispatcher._objectlist;
  var emap=EventDispatcher._objectmap;
  var cmd=rest.substring(0,rest.indexOf(" "));
  var num=rest.substring(rest.indexOf(" ")+1);
  var n=int(num);
  print("dispatching event "+cmd+" to "+elist[n]+"...");
  if (emap[n]==undefined) {
    print("ERROR: object "+n+" is undefined");
  } else {
    log+="//dispatchevent: "+cmd+" "+elist[n]+"\n"+
         "print(\"*** dispatchevent "+cmd+" "+elist[n]+" ***\");\n"+
         "EventDispatcher._objectmap["+n+"].dispatchEvent(new Event(\""+cmd+"\"));\n";
    emap[n].dispatchEvent(new Event(cmd));
    print("finished event "+cmd+" to "+elist[n]+"...");
  }
}
function dispatchmouseevent(rest) {
  var elist=EventDispatcher._objectlist;
  var emap=EventDispatcher._objectmap;
  var cmd=rest.substring(0,rest.indexOf(" "));
  var num=rest.substring(rest.indexOf(" ")+1);
  var n=int(num);
  print("dispatching mouse event "+cmd+" to "+elist[n]+"...");
  if (emap[n]==undefined) {
    print("ERROR: object "+n+" is undefined");
  } else {
    log+="//dispatchevent: "+cmd+" "+elist[n]+"\n"+
         "print(\"*** dispatchevent "+cmd+" "+elist[n]+" ***\");\n"+
         "EventDispatcher._objectmap["+n+"].dispatchEvent(new MouseEvent(\""+cmd+"\"));\n";
    emap[n].dispatchEvent(new MouseEvent(cmd));
    print("finished mouseevent "+cmd+" to "+elist[n]+"...");
  }
}
function showobjects() {
  try {
  print("objects avaiable for constructors "+objectsnames.length);
  for (var i=0;i<objectsnames.length;i++) {
    print(""+i+" = "+objectsnames[i]+
          " instance= "+objects[objectsnames[i]]);
  }
  print("objects created in system "+Sprite.objectlist.length);
  for (var i=0;i<Sprite.objectlist.length;i++) {
    print(""+i+" = "+Sprite.objectlist[i]);
  }
  } catch (e) {
    print("exception caught in showobjects() is avmglue.abc loaded?");
    print(e.getStackTrace());
  }
}
function showframes() {
   print("showing frame listeners");
   try {
   var flist=MovieClip._framelist;
   var fmap=MovieClip._framemap;
   for (var i=0;i<flist.length;i++) {
     var name=flist[i];
     print("["+i+"] "+name);
     for (var j=0;j<fmap[name].length;j++) {
       print("  "+fmap[name][j][0]+" "+fmap[name][j][1]);
     }
   }
   } catch (e) {
     print("ERROR: exception in showframes")
     print(e.getStackTrace());
   }
}
function set(rest) {
  var cmd=rest.substring(0,rest.indexOf(" "));
  var rest=rest.substring(rest.indexOf(" ")+1);
  var objnum=rest.substring(0,rest.indexOf(" "));
  var objn=int(objnum);
  rest=rest.substring(rest.indexOf(" ")+1);
  var value=rest;
  if (cmd=="" || objnum=="" || value=="") {
    print("set <command: totalFrames,currentFrame> <object#> <value> cmd="+cmd+" objnum="+objnum+" value="+value);
  } else {
    switch (cmd) {
      case "totalFrames":
        trace("setting "+objectsnames[objn]+".totalFrames to "+int(value));
        try {
          objects[objectsnames[objn]].totalFrames=int(value);
        } catch(e) {
          print("exception in set totalFrames: "+e.toString());
          print(e.getStackTrace());
        }
        trace("get totalframes "+objects[objectsnames[objn]].totalFrames);
        log+="// set totalFrames "+objectsnames[objn]+" to "+value+"\n"+
             "print(\"*** "+objectsnames[objn]+".totalFrames="+value+" ***\");\n"+
             "objects["+objnum+"].totalFrames="+value+";\n";
        break;
      case "currentFrame":
        trace("setting "+objectsnames[objn]+".currentFrame to "+int(value));
        try {
          objects[objectsnames[objn]].currentFrame=int(value);
        } catch(e) {
          print("exception in set currentFrame: "+e.toString());
          print(e.getStackTrace());
        }
        log+="// set currentFrame "+objectsnames[objn]+" to "+value+"\n"+
             "print(\"*** "+objectsnames[objn]+".currentFrame="+value+" ***\");\n"+
             "objects["+objnum+"].currentFrame="+value+";\n";
        break;
      default:
        print("unknown set command: "+cmd+"\nset <command: totalFames|currentFrame> <object#> <value>");
        break;
    }
  }
  
}
function constructobject(rest) {
  if (rest=="") {
    print("error: loadconstr [n]");
  }
  var n=int(rest);
  try {
    cl=Domain.currentDomain.getClass(objectsnames[n]);
    objects[objectsnames[n]]=new cl();
    Stage.getInstance().addChild(objects[objectsnames[n]]);
    log+="//constructobject: "+objectsnames[n]+"\n"+
         "print(\"*** construct object "+objectsnames[n]+" ***\");\n"+
         "objects["+objectctr+"]=new "+objectsnames[n]+"();\n"+
         "Stage.getInstance().addChild(objects["+objectctr+"]);\n";
    objectctr++;
  } catch (e) {
    print("ERROR: calling constructor "+objectsnames[n]+" "+e);
    print(e.getStackTrace());
  }
}
function loadabcfile(rest) {
  if (rest=="") {
    print("error: loadabcfile [n]");
  }
  print("loading bytecode file "+rest);
  try {
/*
    CONFIG::tracing {
      var bytes:ByteArray;
      bytes=File.fileToByteArray(rest,true);
      Domain.currentDomain.loadBytes(bytes);
    }
*/
      Domain.currentDomain.load(rest);
      log+="//loadabcfile: "+rest+"\n"+
       "print(\"*** loadabcfile "+rest+" ***\");\n"+
       "Domain.currentDomain.load(\""+rest+"\");\n";
  } catch (e) {
    print("error: loading file "+rest);
  }
}
function loadabcblock(rest) {
  if (rest=="") {
    print("error: loadabcblock [name]");
  }
  var fnd=-1;
  for (var i=0;i<abcblocknames.length;i++) {
    if (abcblocknames[i]==rest) {
      fnd=i;
      break;
    }
  }
  if (fnd==-1) {
    print("error block name "+rest+" is not known");
    showblocks();
    return;
  }
  print("loading bytecode block "+rest);
  try {
    Domain.currentDomain.loadBytes(abcblocks[fnd]);
    log+="//loadabcblock: "+rest+"\n"+
       "print(\"*** loadabc "+rest+" ***\");\n"+
       "Domain.currentDomain.loadBytes(abcblocks["+fnd+"]);\n";
  } catch (e) {
    print("error: loading abc block "+rest);
  }
}

var filename;
var filenamectr=0;
var handlers:Array = [];

function parseswf(name) {
  handlers[82]=doABC;
  handlers[72]=doABC;
  handlers[43]=FrameLabel;
  filename=name;
  if (filename.indexOf(".")>-1)
    filename=filename.substring(0,filename.lastIndexOf("."));
//  CONFIG::tracing { var data=File.fileToByteArray(name,false); }
  var data=ByteArray.readFile(name);
	data.endian = "littleEndian";
	var format:String = data.readUTFBytes(3);
	var compressed:Boolean = format=="CWS";
	if (format=="FWS" || format=="CWS") {
    var version=data.readByte();
    var size=data.readUnsignedInt();
		print("SWF format: "+format+" version "+version+", size: "+size);
	} else {
		print("Not a Flash file.");
		return;
	}
	if (compressed) {
  	data.readBytes(data);
	  data.length -= 8;
		data.uncompress();
/*
   CONFIG::tracing {
    var compressdata:ByteArray=new ByteArray();
		compressdata.endian="littleEndian";
		compressdata.writeBytes(data,8,data.length-8);
		data=uncompress(compressdata);
    data.endian="littleEndian";
   }
*/
	}
	data.position = 0;
	var frame:Array = readBox(data);
  var w,h;
  w=Math.round((frame[1]-frame[0])/20);
  h=Math.round((frame[3]-frame[2])/20);
  try {
    Stage.getInstance()._stagewidth=w;
    Stage.getInstance()._stageheight=h;
  } catch (e) {
    print("exception setting Stage width/height, is avmglue.abc loaded?");
    print(e.getStackTrace());
  }
	print("Width: "+w+",Height: "+h);
	var fps_f:uint = data.readUnsignedByte();
	var fps_i:uint = data.readUnsignedByte();
	print("FPS: "+(fps_i+fps_f/256));
	var count:uint = data.readUnsignedShort();
	print("Total frames: "+count);
//  MovieClip._totalFrames=count;
	while (data.bytesAvailable) {
		readSWFTag(data);
	}
  log+="//parseswf: "+name+"\n"+
       "print(parseswf(\""+name+"\"))\n"+
       "parseswf(\""+name+"\");\n";
}

function ShowFrame(tag,id,size,define) {
        print("ShowFrame");
}
function FrameLabel(tag,id,size,define) {
        var name="";
        var ctr=0;
        while (define[ctr]!=0) {
          name+=String.fromCharCode(define[ctr]);
          ctr++;
        }
        print("FrameLabel: "+name);
        objectsnames.push(name);
}
function SymbolClass(tag,id,size,define) {
        count=define[0]+define[1]*256;
        ctr=2;
        print("SymbolClass: count="+count);
        for (var i=0;i<count;i++) {
          var id=define[ctr];+define[ctr+1]*256;
          ctr=ctr+2;
          var name="";
          while (define[ctr]!=0) {
            name+=String.fromCharCode(define[ctr++]);
          }
          print("SymbolClass: id="+id+" name="+name);
        }
}
function doABC(tag,id,size,define) {
        defineabc=new ByteArray;
        if (id==82) {
          var flags=define[0]+define[1]*256+define[2]*256*256+define[3]*256*256*256;
          var actionname="";
          var ctr=4;
          while (define[ctr]!=0)
            actionname+=String.fromCharCode(define[ctr++]);
          ctr++
          print("DoABCDefine: class="+actionname+" saving abc code block");
          while (ctr<size)
            defineabc.writeByte(define[ctr++]);
        } else {
          print("DoABC saving abc code as "+abcblocks.length);
          while (ctr<size)
            defineabc.writeByte(define[ctr++]);
          actionname="frame"+nabcblocks;
        }
        abcblocks[abcblocks.length]=defineabc;
        abcblocknames[abcblocknames.length]=actionname;
				nabcblocks++;
}
function readSWFTag(data:ByteArray) {
	var tag:uint = data.readUnsignedShort();
	var id:int = tag>>6;
	var size:int = tag&0x3F;
	if (size == 0x3F) {
		size = data.readUnsignedInt();
	}
	print("Tag "+id);
	if (handlers[id]!=null) {
		var dump:ByteArray = new ByteArray();
		if (size!=0) {
			data.readBytes(dump,0,size);
//      CONFIG::tracing { data.position+=size; }
		}
		handlers[id](tag, id, size, dump);
	} else {
		data.position += size;
	}
	print("\tsize: "+size);
}
// read compressed box format
function readBox(data:ByteArray):Array {
	var c:Array = [];
	var current:uint = data.readUnsignedByte();
	var size:uint = current>>3;
	var off:int = 3;
	for (var i:int=0; i<4; i+=1) {
		c[i] = current<<(32-off)>>(32-size);
		off -= size;
		while (off<0) {
			current = data.readUnsignedByte();
			c[i] |= off<-8?current<<(-off-8):current>>(-off-8);
			off += 8;
		}
	}
	return c;
}

// main
//go();